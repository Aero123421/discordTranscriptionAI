# Discord文字起こしBot 仕様書

## 1. 概要

本ドキュメントは、「AI駆動型 高性能Discord文字起こしBot」の技術的な仕様、アーキテクチャ、そして主要なワークフローについて詳細に記述するものである。

## 2. アーキテクチャ

本システムは、責務の分離を徹底した**マルチプロセス・アーキテクチャ**を採用している。これにより、特定の処理の遅延がシステム全体に影響を与えることを防ぎ、安定性と耐障害性を高めている。

### 2.1. 主要コンポーネント

-   **`index.js` (メインBotプロセス)**
    -   **役割**: Discord APIとのすべての通信を担うゲートウェイ。
    -   **技術**: `discord.js`
    -   **責務**:
        -   スラッシュコマンド (`/setup`, `/finalize`) の受付と初期処理。
        -   `voiceStateUpdate`イベントを監視し、ユーザーの入退室を検知。
        -   `@discordjs/voice`を用いてボイスチャンネルに接続し、ユーザーごとの音声ストリーム (Opus) を受信。
        -   受信した音声を`prism-media`でPCM形式にデコードし、一時ファイル (`.pcm`) として保存。
        -   保存したファイルパスをジョブキューに`transcribe`ジョブとして登録する。
        -   `messageCreate`イベントを監視し、Q&Aのトリガーとなる返信を検知して`answer-question`ジョブを登録する。

-   **`worker.js` (ワーカープロセス)**
    -   **役割**: CPU負荷の高い、時間のかかる処理を非同期で実行するバックグラウンドワーカー。
    -   **技術**: `better-sqlite3`, `@google/generative-ai`, `child_process`
    -   **責務**:
        -   ジョブキューを定期的にポーリングし、未処理のジョブを取得する。
        -   **`transcribe`ジョブ**: FFmpegを呼び出して`.pcm`を`.wav`に変換後、`transcribe.py`スクリプトを起動して文字起こしを実行。結果をメモリ上の`sessionTranscripts`に保存する。
        -   **`finalize`ジョブ**: 特定セッションの全文字起こしテキストを結合し、Gemini APIに送信して整形・要約を依頼。結果をDiscordに投稿する。
        -   **`answer-question`ジョブ**: `finalize`ジョブと同様にGemini APIを利用し、提供されたコンテキスト（文字起こしテキスト）に基づいてユーザーの質問に回答する。

-   **`transcribe.py` (文字起こしスクリプト)**
    -   **役割**: 音声ファイルからテキストへの変換に特化したスクリプト。
    -   **技術**: `faster-whisper`
    -   **責務**:
        -   コマンドライン引数で`.wav`ファイルのパスを受け取る。
        -   `faster-whisper`モデルをロードし、文字起こしを実行。
        -   結果のテキストを標準出力に書き出す。

-   **`lib/queue.js` (自作ジョブキュー)**
    -   **役割**: メインプロセスとワーカープロセスを疎結合に繋ぐ、永続的なジョブ管理システム。
    -   **技術**: `better-sqlite3`
    -   **責務**:
        -   `jobs`テーブルを持つSQLiteデータベースを管理。
        -   ジョブの追加 (`add`) 機能を提供。
        -   ワーカー側で定期的に`pending`状態のジョブを取得し、`processing` -> `completed` / `failed` と状態を更新するロジックを提供。

### 2.2. データフロー

1.  **録音から文字起こしまで**:
    1.  ユーザーが監視対象VCに参加。
    2.  `index.js`が`voiceStateUpdate`を検知し、VCに接続。
    3.  ユーザーの音声が`.pcm`ファイルとして`./recordings`に保存される。
    4.  `index.js`が`transcribe`ジョブ（pcmPath, userId等を含む）をSQLiteキューに追加。
    5.  `worker.js`がジョブを取得し、ステータスを`processing`に変更。
    6.  `worker.js`が`ffmpeg`で`.pcm`を`.wav`に変換。
    7.  `worker.js`が`child_process.spawn`で`transcribe.py`を起動し、`.wav`パスを渡す。
    8.  `transcribe.py`が文字起こし結果を標準出力に返す。
    9.  `worker.js`が結果を受け取り、メモリ内の`sessionTranscripts`にユーザー名やタイムスタンプと共に保存。
    10. `worker.js`がジョブのステータスを`completed`に変更し、一時ファイルを削除。

2.  **セッション完了処理**:
    1.  管理者が`/finalize`コマンドでセッションIDを指定。
    2.  `index.js`が`finalize`ジョブをキューに追加。
    3.  `worker.js`がジョブを取得。
    4.  `sessionTranscripts`から該当セッションの全テキストを結合。
    5.  整形・要約用のプロンプトを構築し、Gemini APIに送信。
    6.  返ってきたJSONをパースし、タイトル、要約、キーワード、全文を取得。
    7.  全文を`.txt`ファイルとして保存し、Embedと共に指定チャンネルに投稿。
    8.  メモリと一時ファイルをクリーンアップ。

## 3. 主要な仕様詳細

-   **音声形式**: DiscordからはOpus形式で受信し、中間ファイルとして16-bit 48kHzのPCM (`.pcm`) を使用。`faster-whisper`への入力前にWAV (`.wav`) に変換する。
-   **文字起こしモデル**: `faster-whisper`の`small`モデルを`int8`量子化で使用。CPUでの速度と精度のバランスを重視している。
-   **Geminiモデル**: `gemini-1.5-flash`をデフォルトで使用。高速かつ低コストでありながら、十分なコンテキスト長と性能を持つ。
-   **設定の永続化**: サーバーごとの設定（監視カテゴリID、出力チャンネルID）は、ルートディレクトリに`config_{guild.id}.json`というファイル名で保存される。
-   **エラーハンドリング**: 各処理は`try...catch`でラップされ、エラー発生時にはコンソールに出力される。ジョブキューの失敗したタスクは`failed`ステータスとなり、手動での再実行や調査が可能。
-   **データ管理**: 録音された音声ファイルと生成されたテキストファイルは、処理完了後に自動的に削除され、サーバーに不要なデータを残さない設計となっている。
